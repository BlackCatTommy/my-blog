---
title: 技术问题准备
date: 2020-08-30
categories:
 - article
author:
---
技术

## Spring Ioc +aop

### springboot+Spring

### spring mvc

### [mybaits]()

### redis

### 数据库优化

1. 索引 ***
2. [分页查询](分布式事务，mybatis原理，redis，springboot特性，spring源码.html)
3. 数据库隔离级别4种
4. 

### 题

1. Springboot的优势和优略、适用场景、执行流程

2. Springboot或者Spring的加载流程

3. Spring种的对象的作用域

4. Singleton对象引用Prototype会发生什么
   会出现bug，因为单例对象只会初始化一次，单例对象中引用的prototype对象不会发生变
   解决办法：抽象方法+< lookup-method >方法标签

5. Spring种的对象线程安全吗

6. 面向对象的语言特征
   封装、继承、多态

7. jvm的内存模型和回收机制
   
8. 如何终止一个正在取队列消息的线程
   使用interrupt()方法，IsInterrupted()方法来判断，true的话则中断； 如果抛出异常，会将true置位false，需要catch中加逻辑

9. TCP和UDP的区别 HTTP请求的完整流程-从网络协议层面阐述、OSI七层模型
   TCP需要创建稳定的连接，信息传输稳定
   udp直接传送消息，但是不安全并且会丢消息

10. Cookie和Session的区别
    cookie放在浏览器
    Session放在服务器上 cookie中存放sessionId

11. 项目中遇到过的难题
    事故:上线之后服务器的内存过一段时间，就会占用很高，通过在服务器上使用top命令，看到是userService占用最高，jmap 线程号 看到38w consumer对象，检查上线前提交的代码


    订单推送营销，因为64张表，订单数据量比较大，一次性推送64张表的订单，导致订单大量积压，无法及时参与营销活动，方案：任务拆分，一个表一个推送任务


​    

12. jvm 1.7 与1.8的区别
    元空间替换了永久带，元空间在不在虚拟机中，在本地内存。方法区是jvm的规范，永久带是方法区的实现

13. 垃圾回收算法与CMS垃圾回收器的简单介绍
    Concurrent Mark Sweep
    初始标记->并发标记->重新标记->并发清除

14. Redis支持的数据结构
    String 
    Hash
    List
    Set
    Zset

15. 排序算法   快速排序（时间复杂度、是否是稳定排序）介绍几种稳定排序算法
    快排并不稳定、

16. String为什么是final的
    String 是由finla 修饰的char数组，String 会在字符串常量池中创建对象，如果有相同的，直接指向同一，如果可以改变的话，就会改边其他使用该常量的

17. Java种的队列有哪些，区别

    非阻塞：PirorityQueue,ConcurrentLinkedQueue,LinkedList
    ArrayBlockingQueue 基于数组的有界队列
    LinkedBlockingQueue 基于链表实现的可选有界队列
    PirorityBlockingQueue(compareTo) 对数据结构
    DelayBlockingQueue(延时队列，缓存失效和定时任务) 其中的元素必须实现Delayed接口

18. Java内存泄漏问题调查定位：jmap、jstack的使用
    jmap 线程号 
    jstack 线程id ->

19. SpringMVC的运行流程
    dispacherServlet->handlerMapping->action

20. 两个服务之间调用的流程
    RPC进行调用，首先两个服务在启动时注册到注册中心，请求时，通过service调用，Figen可以动态拼接请求地址

21. rpc和http的区别
    RPC：使用rpc框架，我们可以像调用本地方法一样调用其他服务，RPC框架帮我们进行服务的注册和发现，网络通信，消息序列化，对象的序列化和反序列化
    http的话需要我们构建请求url，（请求、请求头）手动消息序列化，然后对返回结果进行反序列化

22. SpringCloud和Dubbo的优缺点
    SpringCloud是一个分布式微服务框架，主要是提供一个规范，他有许多子项目，Eureka，consule，Rabbion，Nettfilx，社区比较活跃没更新也比较快。
    Dubbo也是一个分布式微服务框架，提供了比较完善的服务治理的方案，服务的注册和发现，监控，限流和降级，以及Rpc进行服务的远程调用

23. 分布式一致性CAP理论
    Constance 一致性 分布式系统中同一时刻是否同样的值
    Available 可用性 在集群的部分节点挂掉后，是否可以响应客户端的请求
    Partition tolerance 节点直接进行通信可能失败（导致一致性无法满足。要保证一致性，需要同步相关节点，这时候可用性就无法满足）

24. 常用线程池模式以及不同线程池的使用场景
    ThreadPoolExector
    ScheduledThreadPoolExector

    newFixedThreedPool 创建指定数量的线程
    newSigleThreadPool （线程池中只存在一个线程）
    newScheduleThreadPool (延迟执行、或者是定期执行)
    newCachedThreadPool （短期异步任务 复用之前创建的线程，线程在60s内不使用则会从缓存中移除）

25. ReentrantLock和synchronized的区别
    ReentrantLock是由Doug lee并发类，
    ReentrantLock是Api级别的，synchronized是jvm级别
    ReentrantLock是可中断的，显示加锁和解锁，synchronized隐式加锁和解锁
    ReentrantLock可以获取公平锁

26. synchronized和volatile的区别、适用场景
    synchronized可以保证原子性，可以保证线程安全，可以用在对象、方法、类级别
    volatile只能保证变量的可见性，更新变量之后，会向主内存放一份，然后其他线程使用的时候去主内存中取，volatile可以防止指令重排

27. 分布式锁的三种实现方式
    Redis setNx
    Zookeeper基于异常
    Zookeeper的基于监听

28. NIO的实现原理，什么是一部非阻塞（NIO的最佳实践）
    NIo就是非阻塞io，通过多路复用的方式，其中selector函数监听socket的事件，有事件到达的话进行依次执行

29. Zookeeper的选举原理，使用场景
    所有节点进行主节点的抢注，先注册成功的为主节点，从节点监听主节点，当主节点上的服务器挂掉之后，其他从节点进行抢主
    使用场景：分布式锁、配置中心

30. Zookeeper分布式如何保证数据一致性
     采用ZAB协议，消息广播、崩溃回复和数据同步
    消息广播就是：当一个事务请求过来，leader会将这个请求封装为Proposal事务，放到一个队列中，每个从节点会对应一个队列，持久化本地之后会给主节点返送发送Ack，当超过半数的从节点将事务持久化到本地之后，主节点进行事务commit，各子节点进行commit

31. ThreadExecutor提交的线程数量大于coreSize如何处理
    会放到队列中   coreSize maxMumSize Queue Rejected

32. RPC调用中服务的熔断和限流怎么实现
    熔断：hystrix,快速失败，在服务失败次数超过一定次数之后，hystrix设置改请求为开路，直接返回null或者是其他，过一定时间，处于半开路，如果请求成功，则切换为闭路，否则切换为开路
    限流可以使用漏斗算法和令牌桶算法

33. Mybatis种#{} 和${}的区别
    #{}可以进行预编译，将#{}替换为？，通过preparedStatment.set设值
    ${}进行字符串替换 
    #{}可以防止sql注入

34. RabbitMQ的使用、
    
35. 消息队列的使用场景
    订单：->短信、积分、库存

36. JDK和cglib的实现的aop会在内存动态生成代理对象，还有其他办法吗（AspectJ）

37. 创建类的流程和类加载机制
    加载-验证-准备-解析-初始化-使用-销毁

38. Linux常用命令
    mkdir cd ls
    cat less tail grep
    find 
    df -h
    free -m
    top
    jps 
    jstack jmap

39. 存储过程
    delimiter $$
    create procedure xxx(参数)
       BEGIN
       END$$
    delimiter;

    set @参数 = ‘’
    call xxx()

40. https://segmentfault.com/a/1190000023163102

    

### 多线程

### HashMap和HashTable





