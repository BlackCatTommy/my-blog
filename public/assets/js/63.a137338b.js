(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{403:function(t,a,e){"use strict";e.r(a);var r=e(10),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"并发编程-原子操作-显示锁和aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发编程-原子操作-显示锁和aqs"}},[t._v("#")]),t._v(" 并发编程-原子操作/显示锁和AQS")]),t._v(" "),e("p",[t._v("CAS\nCPU指令级别\n三个值  内存地址v   期望值A   新值B\n循环（死循环、自旋）里不断进行操作")]),t._v(" "),e("h4",{attrs:{id:"出现的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#出现的问题"}},[t._v("#")]),t._v(" 出现的问题")]),t._v(" "),e("p",[t._v("ABA---\x3e解决  版本号\n开销问题：cas操作长期不成功")]),t._v(" "),e("p",[t._v("只能保证一个共享变量的操作（对于多个变量：java封装成一个对象）")]),t._v(" "),e("h4",{attrs:{id:"原子操作类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子操作类"}},[t._v("#")]),t._v(" 原子操作类")]),t._v(" "),e("p",[t._v("基本类型AtomicIBoolean、AutomicInteger\n引用类型AtomicReference、\nAtomicMarkableReference、boolean(是否修改过)\nAtomicStampedReference  修改过几次")]),t._v(" "),e("h4",{attrs:{id:"显示锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#显示锁"}},[t._v("#")]),t._v(" 显示锁")]),t._v(" "),e("p",[t._v("Lock\nlock()\nunlock()")]),t._v(" "),e("p",[t._v("tryLock()")]),t._v(" "),e("p",[t._v("使用Lock   场景 可中断、超时、尝试")]),t._v(" "),e("h4",{attrs:{id:"可重入-锁reentrantloick-和公平、非公平锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可重入-锁reentrantloick-和公平、非公平锁"}},[t._v("#")]),t._v(" 可重入 锁ReentrantLoick  和公平、非公平锁")]),t._v(" "),e("p",[t._v("非公平锁的效率通常效率较高（减少了上下文切换）")]),t._v(" "),e("h4",{attrs:{id:"readwritelock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readwritelock"}},[t._v("#")]),t._v(" ReadWriteLock")]),t._v(" "),e("ol",[e("li",[t._v("适合读多写少的情况")]),t._v(" "),e("li",[t._v("实现 ReentranReadWritetLock")])]),t._v(" "),e("p",[t._v("在写时，读锁和写锁都需要等待")]),t._v(" "),e("p",[t._v("Lock和Condition实现等待通知")]),t._v(" "),e("h4",{attrs:{id:"abstarctqueuedsynchronizer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abstarctqueuedsynchronizer"}},[t._v("#")]),t._v(" AbstarctQueuedSynchronizer")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("lockSupport工具类\npark()阻塞\nunpark(Thread thread)唤醒一个线程")])]),t._v(" "),e("li",[e("p",[t._v("AbstractQueuedSynchronizer模板方法设计模式\n显示锁、读写锁")]),t._v(" "),e("ul",[e("li",[t._v("独占式：")])]),t._v(" "),e("p",[t._v("acquire\nacquireInterruptibly\ntryAcquireNanos")]),t._v(" "),e("ul",[e("li",[t._v("共享式")])]),t._v(" "),e("p",[t._v("acquireShared\nacquireSharedInterruptibly\ntryAcquireSharedNanos")]),t._v(" "),e("ul",[e("li",[t._v("独占式释放")])]),t._v(" "),e("p",[t._v("release")]),t._v(" "),e("ul",[e("li",[t._v("共享式释放")])]),t._v(" "),e("p",[t._v("releaseShared")])]),t._v(" "),e("li",[e("p",[t._v("子类覆盖的方法：")]),t._v(" "),e("p",[t._v("​\t独占是获取 tryAcquire\n​\t独占是释放 tryRelease")]),t._v(" "),e("p",[t._v("​\t共享式获取 tryAcquireShared")]),t._v(" "),e("p",[t._v("​\t共享式释放 tryReleaseShared")]),t._v(" "),e("p",[t._v("​\t这个同步器是否处于独占 isHeldExclusively")]),t._v(" "),e("p",[t._v("​\t同步状态State:\n​         getState 获取当前状态\n​\t\t setState 设置当前同步状态\n​\t\tcompareAndSetState 使用CAS设置状态，保证状态设置的原子性")])]),t._v(" "),e("li")]),t._v(" "),e("p",[t._v("同步队列和等待队列")]),t._v(" "),e("h4",{attrs:{id:"并发容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发容器"}},[t._v("#")]),t._v(" 并发容器")]),t._v(" "),e("h4",{attrs:{id:"concurrnethashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#concurrnethashmap"}},[t._v("#")]),t._v(" ConcurrnetHashMap")]),t._v(" "),e("ol",[e("li",[t._v("hash算法（常见取模）\nhash冲突：1.开放寻址、2.再散列3.链地址法\nmd4,md5,sha-hash算法，算法不可逆")]),t._v(" "),e("li",[t._v("散列")]),t._v(" "),e("li",[t._v("putifAbsent()")])]),t._v(" "),e("p",[t._v("位运算")]),t._v(" "),e("h4",{attrs:{id:"hashtable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[t._v("#")]),t._v(" HashTable")])])}),[],!1,null,null,null);a.default=v.exports}}]);