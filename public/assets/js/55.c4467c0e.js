(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{412:function(t,s,e){"use strict";e.r(s);var v=e(10),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"redis常见面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis常见面试题"}},[t._v("#")]),t._v(" Redis常见面试题")]),t._v(" "),e("h3",{attrs:{id:"分布式锁的问题："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的问题："}},[t._v("#")]),t._v(" 分布式锁的问题：")]),t._v(" "),e("ol",[e("li",[t._v("​\tsetNX命令")]),t._v(" "),e("li",[t._v("死锁（异常或者是宕机等等）：需要设置超时时间  set  ex nx")]),t._v(" "),e("li",[t._v("超时执行解锁导致并发：执行超时，锁已经释放，设置守护线程，续期超时时间")]),t._v(" "),e("li",[t._v("锁错误解除：t1执行超时，锁释放，t2线程获取锁，当t1执行完成，去释放了t2的锁")]),t._v(" "),e("li",[t._v("不可重入")])]),t._v(" "),e("h3",{attrs:{id:"redis持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化机制"}},[t._v("#")]),t._v(" Redis持久化机制")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("RDB 快照文件，  恢复较快，但是丢失数据严重")])]),t._v(" "),e("li",[e("p",[t._v("AOF 以追加的方式加入日志文件   实时，但是恢复的时候比较慢")]),t._v(" "),e("p",[t._v("原理：fork一个子进程，子进程将父进程的数据复制到子进程的内存中，然后写入到临时文件，持久化结束后，用临时文件替换上次的快照文件")])])]),t._v(" "),e("h3",{attrs:{id:"缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"}},[t._v("#")]),t._v(" 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级")]),t._v(" "),e("ol",[e("li",[t._v("缓存雪崩：缓存失效、大量请求直接访问数据库，导致数据库宕机，引起整个系统的瘫痪\n加锁、或者是队列的形式避免大量请求直接访问数据库")]),t._v(" "),e("li",[t._v("缓存穿透：缓存命中，多次缓存数据库中没有的数据。 采用布隆过滤器：将可能存在的结果都放到一个大的bitmap中")]),t._v(" "),e("li",[t._v("缓存击穿：当一个数据是热点数据，当失效时有大量请求访问，击穿缓存，直接访问数据库\n解决办法：显示setnx来设置一个短期的key来锁住")]),t._v(" "),e("li",[t._v("将相关缓存先缓存一份缓存中\n定时刷新")]),t._v(" "),e("li",[t._v("热点数据：热点数据缓存才有意义")])]),t._v(" "),e("h3",{attrs:{id:"memcache和redis的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memcache和redis的区别"}},[t._v("#")]),t._v(" Memcache和Redis的区别")]),t._v(" "),e("ol",[e("li",[t._v("redis可以持久化")]),t._v(" "),e("li",[t._v("redis支持更多的数据结构")]),t._v(" "),e("li",[t._v("redis单线程")])]),t._v(" "),e("h3",{attrs:{id:"redis单线程但是还是很快的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis单线程但是还是很快的原因"}},[t._v("#")]),t._v(" Redis单线程但是还是很快的原因")]),t._v(" "),e("ol",[e("li",[t._v("基于内存操作")]),t._v(" "),e("li",[t._v("避免了上下文切换")]),t._v(" "),e("li",[t._v("使用非阻塞nio的多路复用机制")])])])}),[],!1,null,null,null);s.default=_.exports}}]);